<?php

use Drupal\views\ViewExecutable;
use Drupal\node\NodeInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Component\Utility\UrlHelper;
use Drupal\Core\Cache\Cache;
use Drupal\views\Plugin\views\cache\CachePluginBase;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\field\FieldConfigInterface;
use Drupal\migrate_tools\Form\MigrationExecuteForm;
use Drupal\migrate\Plugin\MigrationInterface;
use Drupal\migrate_tools\MigrateBatchExecutable;
use Drupal\migrate\MigrateMessage;
use Drupal\migrate\MigrateMessageInterface;

/**
 * @file
 * File description.
 *
 * Long description.
 */

/**
 * Implements hook_page_attachments.
 */
function stanford_events_page_attachments(array &$attachments) {

  // Get the node from the route.
  $node = \Drupal::routeMatch()->getParameter('node');

  // Not a node.. Then just continue.
  if (!$node instanceof NodeInterface || $node->bundle() != 'stanford_event') {
    return;
  }

  $attachments['#attached']['library'][] = 'stanford_events/event_node';
}


/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function stanford_events_node_presave(EntityInterface $entity) {
  if ($entity->bundle() != "stanford_event") {
    return;
  }

  $rabbit_hole = \Drupal::config('rabbit_hole.behavior_settings.node_type_' . $entity->bundle());
  $token_service = \Drupal::service('token');

  // When the source field is filled out on a news item we want to set the
  // redirect options so it doesn't get indexed.
  if ($rabbit_hole) {
    /** @var \Drupal\Core\Utility\Token $token_service */
    $target = $token_service->replace("[node:su_event_source:uri]", ['node' => $entity]);

    // Check if the token that was provided is actually a url. If it is, then we
    // can set the rabbit hole action to redirect to that url.
    if (is_string($target) && UrlHelper::isValid($target, TRUE)) {
      $entity->set('rh_action', 'page_redirect');
      $entity->set('rh_redirect', $target);
      $entity->set('rh_redirect_response', 301);
    }
    else {
      $entity->set('rh_action', 'bundle_default');
      $entity->set('rh_redirect', '');
    }
  }

  // If an event item is being edited or saved, clear out some cache tags.
  Cache::invalidateTags(["node_list:{$entity->bundle()}"]);
}

/**
 * Implements hook_views_post_render().
 *
 * Views render arrays contain a cache tag "node_list". This cache tag is
 * cleared every time ANY node is created, edited or deleted. When this happens
 * every view on the site gets its cache flushed. This causes poor performance
 * since a view would get flushed even if it has no relation to that node. To
 * assist in cache tags, we create a custom cache tag based on the node type
 * filter on the view. Its a small improvement but will have huge impact in
 * keeping cached renders much longer.
 *
 * @see stanford_event_node_presave()
 * @see stanford_event_taxonomy_term_presave ()
 */
function stanford_events_views_post_render(ViewExecutable $view, &$output, CachePluginBase $cache) {

  // Node Base Table Views.
  if ($view->id() == 'stanford_events') {
    $output['#attached']['library'][] = 'stanford_events/event_views';

    $node_list_position = array_search('node_list', $output['#cache']['tags']);
    unset($output['#cache']['tags'][$node_list_position]);
    foreach ($view->filter['type']->value as $node_type) {
      $output['#cache']['tags'][] = "node_list:$node_type";
    }
  }

}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function stanford_events_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {

  // Only run on stanford news items.
  if ($entity->bundle() !== "stanford_event" || !node_is_page($entity)) {
    return;
  }

  $rh_action = $entity->get('rh_action')->getString();
  $rh_redirect = $entity->get('rh_redirect')->getString();

  // Display a message to the user that this page would redirect to another
  // location for other users.
  if ($rh_action == "page_redirect" && !empty($rh_redirect)) {
    \Drupal::messenger()
      ->addWarning(t('This page will redirect to @url for other visitors.', ['@url' => $rh_redirect]));
  }

}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the config form to add the migrate_tools UI.
 */
function stanford_events_form_config_pages_stanford_events_importer_form_alter(array &$form, FormStateInterface $form_state) {

  // Build the migration execution form.
  $options = [
    'import' => t('Import'),
    'rollback' => t('Rollback'),
    'stop' => t('Stop'),
    'reset' => t('Reset'),
  ];

  $form['operations'] = [
    '#type' => 'details',
    '#title' => t('Execution options'),
    '#open' => TRUE,
  ];

  $form['operations']['operation'] = [
    '#type' => 'radios',
    '#title' => t('Operation'),
    '#description' => t('Choose an operation to run.'),
    '#options' => $options,
    'import' => [
      '#description' => t('Imports all previously unprocessed records from the source, plus any records marked for update, into destination event items.'),
    ],
    'rollback' => [
      '#description' => t('Deletes all Event objects created by the import.'),
    ],
    'stop' => [
      '#description' => t('Cleanly interrupts any import or rollback processes that may currently be running.'),
    ],
    'reset' => [
      '#description' => t('Sometimes a process may fail to stop cleanly, and be left stuck in an Importing or Rolling Back status. Choose Reset to clear the status and permit other operations to proceed.'),
    ],
  ];

  $form['options'] = [
    '#type' => 'details',
    '#title' => t('Additional execution options'),
    '#open' => FALSE,
  ];

  $form['options']['update'] = [
    '#type' => 'checkbox',
    '#title' => t('Update'),
    '#description' => t('Check this box to update all previously-imported content in addition to importing new content. Leave unchecked to only import new content'),
  ];

  $form['options']['force'] = [
    '#type' => 'checkbox',
    '#title' => t('Ignore dependencies'),
    '#description' => t('Check this box to ignore dependencies when running imports - all tasks will run whether or not their dependent tasks have completed.'),
  ];

  $form['options']['limit'] = [
    '#type' => 'number',
    '#title' => t('Limit to:'),
    '#size' => 10,
    '#description' => t('Set a limit of how many items to process for each migration task.'),
  ];

  // Add our submit handler.
  $form['actions']['submit']['#submit'][] = "stanford_events_form_config_pages_stanford_events_importer_form_alter_submit";

  return $form;
}

/**
 * Submit handler for the config form override.
 */
function stanford_events_form_config_pages_stanford_events_importer_form_alter_submit($form, &$form_state) {
  $operation = $form_state->getValue('operation');

  if ($form_state->getValue('limit')) {
    $limit = $form_state->getValue('limit');
  }
  else {
    $limit = 0;
  }

  if ($form_state->getValue('update')) {
    $update = $form_state->getValue('update');
  }
  else {
    $update = 0;
  }
  if ($form_state->getValue('force')) {
    $force = $form_state->getValue('force');
  }
  else {
    $force = 0;
  }

  $migrations = stanford_migrate_migration_list();
  $migration_plugin = $migrations["stanford_events"]["stanford_events_importer"] ?? FALSE;

  if (!$migration_plugin) {
    \Drupal::messenger()->addError('Could not find the stanford_events_importer migration!');
  }

  $migrateMessage = new MigrateMessage();
  switch ($operation) {
    case 'import':
      $options = [
        'limit' => $limit,
        'update' => $update,
        'force' => $force,
      ];
      $executable = new MigrateBatchExecutable($migration_plugin, $migrateMessage, $options);
      $executable->batchImport();
      break;

    case 'rollback':
      $options = [
        'limit' => $limit,
        'update' => $update,
        'force' => $force,
      ];
      $executable = new MigrateBatchExecutable($migration_plugin, $migrateMessage, $options);
      $executable->rollback();
      break;

    case 'stop':
      $migration_plugin->interruptMigration(MigrationInterface::RESULT_STOPPED);
      break;

    case 'reset':
      $migration_plugin->setStatus(MigrationInterface::STATUS_IDLE);
      break;
  }
}


/**
 * [stanford_events_format_date description]
 * @param  [type] $raw [description]
 * @param  [type] $obj [description]
 * @return [type]      [description]
 */
function stanford_events_schedule_format_date($raw, $obj) {
  if (!is_numeric($raw)) {
    return;
  }
  return \Drupal::service('date.formatter')->format($raw, 'stanford_long_day_date_year');
}
